BEGIN {
    header_file = ARGV[2];
    tests_file = ARGV[3];
    delete ARGV[2]
    delete ARGV[3]
    header_guard = gensub(/\W/, "_", "g", toupper(header_file));
}

/^\/\*\*\s*@cond\s+\w+\s*\*\/\s*$/ {
    printf "#line %d \"%s\"\n", FNR + 1, FILENAME
    cond_nesting++
    cond_name[cond_nesting] = gensub(/^\/\*\*\s*@cond\s+(\w+)\s*\*\/\s*$/, "\\1", "1");
    cond_start[cond_nesting] = FNR
    if (cond_name[cond_nesting] == "HEADER") {
        initialize_header();
        in_header = 1;
        printf "#line %d \"%s\"\n", FNR + 1, FILENAME >header_file        
    }
    else if (cond_name[cond_nesting] == "TESTS") {
        in_tests = 1;
        printf "#line %d \"%s\"\n", FNR + 1, FILENAME >tests_file
    } else if (cond_name[cond_nesting] == "GENERIC") {
        do_instantiate = 1
        instantiate_public = 0
    } 
    next
}

/^\/\*\*\s*@endcond\s*\*\/\s*$/ {
    if (cond_nesting == 0) {
        print FILENAME, FNR ":", "@endcond without @cond" >"/dev/stderr"
        exit 1
    }
    if (cond_name[cond_nesting] == "HEADER") {
        in_header = 0;
        printf "#line %d \"%s\"\n", FNR + 1, FILENAME
    } else if (cond_name[cond_nesting] == "TESTS") {
        in_tests = 0;
        printf "#line %d \"%s\"\n", FNR + 1, FILENAME
    } else if (cond_name[cond_nesting] == "GENERIC") {
        if (instantiate_args) {
            $0 = $0 "\n" instantiate_args sprintf("\n#line %d \"%s\"", FNR + 1, FILENAME)
            instantiate_args = ""
        }
        do_instantiate = 0;
        print > (in_tests ? tests_file : "/dev/stdout")
        if (instantiate_public)
            print > header_file
    } 
    cond_nesting--
    next
}

/^\/\*\*\s*@endcond\s+\w+/ {
    print FILENAME, FNR ":", "garbage after @endcond" >"/dev/stderr"
    exit 1
}

function join(line1, line2) {
    return line1 == "" ? line2 : line1 "\n" line2;
}

function initialize_header( hdef) {
    if (header_initialized)
        return;
    printf "/* This file is autogenerated from %s */\n", FILENAME >header_file
    printf "#ifndef %s\n#define %s 1\n#ifdef __cplusplus\nextern \"C\"{\n#endif\n", \
        header_guard, header_guard >header_file
    header_initialized = 1
}

function dump_section(what, section_start, section, mode,   decl, def, macro_name, macro_body) {
    sub(/^\s+/, "", section);
    
    if (what == "define" && is_generic) {
        macro_name = gensub(/^#\s*define\s+(\w+).*$/, "\\1", "1", section);
        what = "generic_define"

        if (do_instantiate)
        {
            instantiate_args = join(instantiate_args, "#undef " macro_name)
            if (mode != "private")
                instantiate_public = 1;
        } else if (mode != "private")
        {
            macro_body = gensub(/^#\s*define\s+\w+(\([^)]*\))?\s+(\w+)\s*$/, "\\2", "1", section);
            if (macro_body == macro_name)
            {
                section = sprintf("#ifndef %s\n#error \"%s is not defined\"\n#endif", macro_name, macro_name);
            }
            else
            {
                section = sprintf("#ifndef %s\n%s\n#define %s__default 1\n#endif", macro_name, section, macro_name);
                aftermath = join(aftermath,
                                 sprintf("#ifdef %s__default\n#undef %s\n#undef %s__default\n#endif", macro_name, macro_name, macro_name));
            }
        }
        else
        {
            aftermath = join(aftermath, "#undef " macro_name)
            mode = "protected"
        }
    }
    
    if (what == "define" || what == "if" || section ~ /^static\>/)
    {
        decl = section
        def = ""
    }
    else if (what == "generic_define")
    {
        decl = section
        def = section
    }
    else if (section ~ /^typedef\>/)
    {
        if (mode != "protected")
        {
            decl = section
            def = ""
        }
        else
        {
            decl = gensub(/^([^{]*)\{.*\}([^}]*)$/, "\\1\\2", "1", section);
            def = gensub(/^typedef\s*(.*\})([^}]*)$/, "\\1;", "1", section);
        }
    }
    else
    {
        decl = "extern " gensub(/[={].*$/, ";\n", "1", section);
        def = section;
    }
    if (mode == "private")
        decl = "";
    
    if (decl)
    {
        initialize_header();
        printf "#line %d \"%s\"\n%s\n", section_start, FILENAME, decl >header_file
    }
    if (def)
    {
        printf "#line %d \"%s\"\n%s\n", section_start, FILENAME, def
        printf "#line %d \"%s\"\n", FNR + 1, FILENAME
    }
}

function process_section(mode,  what, section, section_start)
{
    section_start = FNR + 1
    while (getline > 0) {
        section = join(section, $0)
        if (!what) {
            if (/^#\s*define/)
                what = "define"
            else if (/^#\s*if/)
                what = "if"
            else if (/\{/)
                what = "brace"
            else if (/;/)
                break;
        }
        if (what == "define" && !/\\$/)
            break;
        if (what == "brace" && /^\}/)
            break
        if (what == "if" && /^\s*#\s*endif/)
            break
    }
    dump_section(what, section_start, section, mode);
}

function process_testcase(comment,  testdef, test_descr, test_condition, test_name, test_args, current_case,
                          test_call_args, test_arg_list, i, n, arg_name, arg_type, arg_type_id) {
    printf "#line %d \"%s\"\n", FNR + 1, FILENAME >tests_file
    while (getline > 0) {
        testdef = join(testdef, $0)
        if (/{/)
            break;
    }
    test_descr = gensub(/^\s*\/\*\*\s*([^\n]+).*$/, "\\1", "1", comment);
    gsub(/\s*@testcase\s*/, "", test_descr);
    print testdef >tests_file

    test_condition = ""
    if (testdef ~ /^\s*#\s*if/) {
        test_condition = gensub(/^([^\n]+).*$/, "\\1", "1", testdef);
        sub(/^[^\n]+\n/, "", testdef);
    }

    gsub(/\s+/, " ", testdef);
    gsub(/^ | $/, "", testdef);
    gsub(/ ?, ?/, ",", testdef);
    gsub(/ ?\( ?/, "(", testdef);
    gsub(/ ?\) ?/, ")", testdef);
    gsub(/ ?\* ?/, "*", testdef);

    test_name = gensub(/^(static )?void (\w+)\(.*$/, "\\2", "1", testdef);
    test_args = gensub(/^[^(]+\(([^)]*)\).*$/, "\\1", "1", testdef);
    current_case = sprintf("%s(@@@);\n", test_name);
    test_call_args = "";
    if (test_args != "void")
    {
        n = split(test_args, test_arg_list, ",");
        for (i = 1; i <= n; i++)
        {
            gsub(/(const|volatile|restrict) /, "", test_arg_list[i]);
            test_arg_list[i] = gensub(/(\w+) ?\[[^]]*\]$/, "*\\1", "1", test_arg_list[i]);
            arg_name = gensub(/^.*\W(\w+)$/, "\\1", "1", test_arg_list[i]);
            arg_type = gensub(/^(.*\W)\w+$/, "\\1", "1", test_arg_list[i]);
            sub(/ $/, "", arg_type);
            arg_type_id = arg_type;
            gsub(/\*/, "_ptr", arg_type_id);
            gsub(/ /, "_", arg_type_id);
            test_call_args = test_call_args "*" arg_name ","

            current_case = sprintf("#line 1 \"//extract_code.%s%d.c\"\n"  \
                                   "{\n"                                \
                                   "%s %s__values[] = {TESTVAL_GENERATE__%s};\n" \
                                   "%s *%s;\n"                          \
                                   "for (%s = %s__values;\n"            \
                                   "%s < %s__values + sizeof(%s__values) / sizeof(*%s__values);\n" \
                                   "%s++)\n"                            \
                                   "{\n"                                \
                                   "#ifndef TESTVAL_LOG_ARGS_%s\n"      \
                                   "#define TESTVAL_LOG_ARGS_%s(_val) (_val)\n" \
                                   "#endif\n"                           \
                                   "TESTVAL_LOG(%s, %s, *%s);\n"        \
                                   "%s\n"                                 \
                                   "#ifdef TESTVAL_CLEANUP__%s\n"       \
                                   "TESTVAL_CLEANUP__%s(*%s);\n"        \
                                   "#endif\n"                           \
                                   "}\n"                                \
                                   "}",
                                   test_name, i,
                                   arg_type, arg_name, arg_type_id,
                                   arg_type, arg_name,
                                   arg_name, arg_name,
                                   arg_name, arg_name, arg_name, arg_name,
                                   arg_name,
                                   arg_type_id,
                                   arg_type_id,
                                   arg_name, arg_type_id, arg_name,
                                   current_case,
                                   arg_type_id,
                                   arg_type_id, arg_name);
        }
        sub(/,$/, "", test_call_args);
    }

    sub(/@@@/, test_call_args, current_case);
    current_case = sprintf("TEST_START(\"%s\");\n%s\nTEST_END;\n",
                           gensub(/"/, "\\\\\"", "g", test_descr),
                           current_case);

    if (test_condition) {
        current_case = sprintf("%s\n%s#else\nTEST_SKIP(\"%s\");\n#endif",
                               test_condition,
                               current_case,
                               gensub(/"/, "\\\\\"", "g", test_descr));
    }

    testcases = join(testcases, current_case)
    
    while (getline > 0) {
        print >tests_file
        if (test_condition ? /^\s*#\s*endif/ : /^}/)
            break;
    }
    if (!in_tests)
        printf "#line %d \"%s\"\n", FNR + 1, FILENAME
}


/^\s*\/\*\*/ {
    comment = $0
    if (!/\*\/\s*$/) {
        while (getline > 0) {
            comment = join(comment, $0)
            if (/\*\/\s*$/)
                break
        }
    }
    print comment 
    if (comment ~ /@public\>/) {
        process_section("public")
    } else if (comment ~ /@protected\>/) {
        process_section("protected")
    } else if (comment ~ /@private\>/) {
        process_section("private")
    } else if (comment ~ /@generic\>/) {
        is_generic = 1
    } else if (comment ~ /@testcase\>/) {
        process_testcase(comment);
    }
    next
}

do_instantiate && /^\s*#\s*define/ {
    macro_name = gensub(/^\s*#\s*define\s+(\w+).*$/, "\\1", "1");
    instantiate_args = join(instantiate_args, "#undef " macro_name)
}

in_tests && /STATIC_ARBITRARY\([0-9]+\)/ {
    bitness = gensub(/^.*STATIC_ARBITRARY\(([0-9]+)\).*$/, "\\1", "1") + 0;
    sub(/STATIC_ARBITRARY\([0-9]+\)/, int(rand() * (2 ** bitness)) "U");
}

{
    if (in_header)
        print >header_file
    else if (in_tests)
        print >tests_file
    else
        print
}

END {
    if (cond_nesting > 0)
    {
        print FILENAME, cond_start[cond_nesting] ": conditional section", cond_name[cond_nesting], "not terminated" >"/dev/stderr"
        exit 1
    }

    if (header_initialized)
    {
        print aftermath
        printf "%s\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n#endif /* %s */\n", aftermath, header_guard >header_file
        if (is_generic)
            printf "#undef %s\n", header_guard >header_file
    }
    if (testcases) {
        print "#line 1 \"//extract_code.all.c\"" >tests_file
        print "int main(void)" >tests_file
        print "{" >tests_file
        print "SET_RANDOM_SEED();" >tests_file
        print "#ifdef TESTSUITE\n" >tests_file
        print "fprintf(stderr, \"%s:\\n\", TESTSUITE);" >tests_file
        print "#endif" >tests_file
        print testcases >tests_file
        print "#if NONFATAL_ASSERTIONS" >tests_file
        print "if (assert_failure_count > 0)" > tests_file
        print "{" >tests_file
        print "fprintf(stderr, \"%u assertions FAILED\\n\", assert_failure_count);" >tests_file
        print "return 1;" >tests_file
        print "}" >tests_file
        print "#endif" >tests_file
        print "return 0;" >tests_file
        print "}" >tests_file
    }
}


